Traceback (most recent call last):
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\jupyter_cache\executors\utils.py", line 51, in single_nb_execution
    executenb(
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.8_3.8.2800.0_x64__qbz5n2kfra8p0\lib\asyncio\base_events.py", line 616, in run_until_complete
    return future.result()
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "c:\users\hehez\onedrive\github\pyppg-handbook\venv\lib\site-packages\nbclient\client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import math
import json
from hapy.plotting import HCFigure
import os
import sys
import datetime as datetime
import numpy as np

def surcharge_plot(asdf, plot_range, ground_data):
    """
    Create surcharge plot and add to HA figure template
    input: matplotlib axes (the whole range for the plot)
    returns: surcharges
    """
    # axis for the surcharge plot
    # groundAx = asdf.addPlotAxes([plot_range[0]/8.5, (10.5-2.5)/11,
    #                             (plot_range[2]/2-0.05)/8.5, 2.45/11])
    groundAx = asdf.addPlotAxes([(plot_range[2]/2+0.05 + plot_range[0])/8.5, (10.5-2.5)/11,
                                 (plot_range[2]/2)/8.5, 2.45/11])
    
    groundAx.get_xaxis().set_visible(False)
    groundAx.get_yaxis().set_visible(False)
    
    groundAx.set_axis_off()
    logo = os.path.join(os.path.dirname('file'),'images','surcharge_pic.png')
    logoimg = mpl.image.imread(logo)
    groundAx.imshow(logoimg, interpolation='none')
    
    # adding measures to the plot
    groundAx.text(120, 0.5, 'a = ' + str(ground_data["slope_a"]) + ' ft', fontsize=10)
    groundAx.text(380, 20, 'Elev. ' + str(ground_data["ground_elevation"])  + ' ft', fontsize=10)
    groundAx.text(320, 135, 'H = ' + str(ground_data["surcharge_elevation"]) + ' ft' + "\n" + 
                             '$\gamma$ = ' + str(ground_data["surcharge_weight"]) + ' pcf', fontsize=10)

    return groundAx

def deform_plot(asdf, plot_range, ground_data, layer_num):
    """
    Create ground deformation plot and add to HA figure template
    input: matplotlib axes (the whole range for the plot)
    returns: ground deformation plot
    """
    # axis for the deformation plot
    # deformAx = asdf.addPlotAxes([(plot_range[2]/2+0.05 + plot_range[0])/8.5, (10.5-2.5)/11,
    #                              (plot_range[2]/2)/8.5, 2.45/11])
    deformAx = asdf.addPlotAxes([(plot_range[2]/2+0.48 + plot_range[0])/8.5, (10.5-5+0.2)/11,
                                 (plot_range[2]/2-0.5)/8.5, 2.25/11])

    ax = deformAx
    ax.set_xlabel('Horizontal location X (ft)')
    ax.set_ylabel('Total settlement (ft)', labelpad=-3)
    
    deform_store = []
    for point_x in range(0, 200):    
        cal_sum =[]
        for layer_n in range(0, layer_num):
            # print(layer_calculaton(asdf, plot_range, ground_data, layer_n, point_x))
            cal_sum.append(layer_calculaton(asdf, plot_range, ground_data, layer_n, point_x))
    
        eps_total = 0
        for layer_n in range(0, layer_num):
            eps_total += cal_sum[layer_n][9]
        
        deform_store.append([point_x, -eps_total])

    ax.plot(np.array(deform_store)[:,0], np.array(deform_store)[:,1])

    return ax

def layer_calculaton(asdf, plot_range, ground_data, layer_num, point_x):
    """
    Calculate and plot results for each layer
    input: ground_data for calculation, layer_num to locate layers, 
           plot_range to generate axies, point_x for the x of cal. point
    returns: layer calculation result. 
    """
    
    # find calculation depth
    if layer_num == 0:
        z = ground_data["layers"][0]["thickness"]/2  # the middle of the first layer
    else:
        z = 0
        for n in range(0, layer_num):
            z = z + ground_data["layers"][n]["thickness"]
        z = z + ground_data["layers"][layer_num]["thickness"]/2
            
    # find alpha, beta, and lambda
    if point_x > 0:
        lamb = np.arctan(z/point_x)
    elif point_x == 0:
        lamb = math.pi/2
    elif point_x < 0:
        lamb = math.pi - np.arctan(z/abs(point_x))
    
    slope_a = ground_data["slope_a"]
    if point_x > slope_a:
        bta = math.pi - np.arctan(z / (point_x-slope_a))
    elif point_x == slope_a:
        bta = math.pi/2
    elif point_x < slope_a:
        bta = np.arctan(z / (slope_a-point_x))
        
    alp = math.pi - lamb - bta
    
    sig_z = ground_data["surcharge_elevation"] * ground_data["surcharge_weight"] * \
    (ground_data["slope_a"]*bta + point_x*alp)/(math.pi * slope_a)
    d_p = sig_z
    
    # find cumulative original ground pressure (self weight)
    if layer_num == 0:
        sig_v = ground_data["layers"][0]["thickness"]/2 * \
                ground_data["layers"][0]["effective_unit_weight"] # the middle of the first layer
    else:
        sig_v = 0
        for n in range(0, layer_num):
            sig_v = sig_v + ground_data["layers"][n]["thickness"] * \
                            ground_data["layers"][n]["effective_unit_weight"] 
        sig_v = sig_v + ground_data["layers"][layer_num]["thickness"]/2 * \
                    ground_data["layers"][layer_num]["effective_unit_weight"] 
    
    # calculated layer deformaton eps_c 
    # 8-13 NC clay, 8-17 OC clay when sig_v + d_p <= sig_p, 8-19 
    sig_p = sig_v * ground_data["layers"][layer_num]["OCR"]
    ai = sig_z/(ground_data["surcharge_elevation"] * ground_data["surcharge_weight"])            
    
    OCR = ground_data["layers"][layer_num]["OCR"]
    if OCR <= 1:
        eps_c = ground_data["layers"][layer_num]["thickness"] * \
            ground_data["layers"][layer_num]["CR"] * math.log10((sig_z+sig_v)/sig_v)
        # print(ground_data["layers"][layer_num]["CR"])
    elif OCR > 1 and (sig_z+sig_v) <= sig_p:
        eps_c = ground_data["layers"][layer_num]["thickness"] * \
            ground_data["layers"][layer_num]["RR"] * math.log10((sig_z+sig_v)/sig_v)
    elif OCR > 1 and (sig_z+sig_v) > sig_p:
        eps_c = ground_data["layers"][layer_num]["thickness"] * \
            ground_data["layers"][layer_num]["RR"] * math.log10(sig_p/sig_v) + \
            ground_data["layers"][layer_num]["thickness"] * ground_data["layers"][layer_num]["CR"] * \
            math.log10((sig_z+sig_v)/sig_p)       
    
    return [z, alp, bta, lamb, sig_z, d_p, sig_v, sig_p, ai, eps_c] 
    
def layer_plot(asdf, plot_range, ground_data, cal_sum, layer_n, layer_num):
    # total depth of ground for scalled plot
    total_h = 0
    for n in range(0, layer_num):
        total_h += ground_data["layers"][n]["thickness"]
    
    # find the bottom (y_0) of new layer plot 
    sec_t = 0 # the thickness of all ploted blocks (including the current one)
    for n in range(0, layer_n+1):
        sec_t += ground_data["layers"][n]["thickness"]/total_h * plot_range[3]
    sec_bottom = plot_range[1] + plot_range[3] - sec_t   
 
    # the height of the current lyaer plot    
    sec_h = ground_data["layers"][layer_n]["thickness"]/total_h * plot_range[3]
      
    # the width of each layer of soil plot
    sec_w = plot_range[2]/2 - 0.05    
    
    layerAx = asdf.addPlotAxes([plot_range[0]/8.5,  sec_bottom/11, 
                                sec_w/8.5, sec_h/11]) 
    layerAx.get_xaxis().set_visible(False)
    layerAx.get_yaxis().set_visible(False)
    
    layerAx.text(0.1, 0.5, 'Hi = '+str(ground_data["layers"][layer_n]["thickness"])+' ft', va='center', ha='center', fontsize=8)
    
    soilAx = asdf.addPlotAxes([(plot_range[0]+0.8)/8.5,  sec_bottom/11, 
                                0.5/8.5, sec_h/11]) 
    soilAx.get_xaxis().set_visible(False)
    soilAx.get_yaxis().set_visible(False)
    soilAx.set_axis_off    
    
    if 'M' in ground_data["layers"][layer_n]["soil_type"]:
        soilAx.bar(1, 2, edgecolor='blue', color='white', hatch='...')
    elif 'S' in ground_data["layers"][layer_n]["soil_type"]:
        soilAx.bar(1, 2, edgecolor='blue', color='white', hatch='xx')    
    elif 'G' in ground_data["layers"][layer_n]["soil_type"]:
        soilAx.bar(1, 2, edgecolor='blue', color='white', hatch='OO')      
    soilAx.text(1.1, 1, str(ground_data["layers"][layer_n]["soil_type"]), va='center', ha='center')    
    
    # print intermediate results
    layerAx.text(0.7, 0.4, '$\epsilon_c$  = '+str(round(cal_sum[layer_n][9],2))+' ft'+'\n',
                    va='center', ha='center', fontsize=8)
        
    soilAx.set_xlim([1,1])
    soilAx.set_ylim([0,2])
    return layerAx, soilAx


------------------

[1;31m---------------------------------------------------------------------------[0m
[1;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [1;32mIn[2], line 6[0m
[0;32m      4[0m [38;5;28;01mimport[39;00m [38;5;21;01mmath[39;00m
[0;32m      5[0m [38;5;28;01mimport[39;00m [38;5;21;01mjson[39;00m
[1;32m----> 6[0m [38;5;28;01mfrom[39;00m [38;5;21;01mhapy[39;00m[38;5;21;01m.[39;00m[38;5;21;01mplotting[39;00m [38;5;28;01mimport[39;00m HCFigure
[0;32m      7[0m [38;5;28;01mimport[39;00m [38;5;21;01mos[39;00m
[0;32m      8[0m [38;5;28;01mimport[39;00m [38;5;21;01msys[39;00m

[1;31mModuleNotFoundError[0m: No module named 'hapy'
ModuleNotFoundError: No module named 'hapy'

